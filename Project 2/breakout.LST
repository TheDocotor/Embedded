C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BREAKOUT
OBJECT MODULE PLACED IN breakout.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe breakout.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          #include <c8051f020.h>
   2          #include <lcd.h>
   3          #include<stdio.h>
   4          #include<stdlib.h>
   5          
   6          long score_2, score, score_1, high_score = 0;
   7          sbit player_sw = P1^7;
   8          char switches, bonk = 0; 
   9          bit player, num_player, su = 0;
  10          int int_cnt, t_cnt, t_cnt_init, pad_w, pad_w2, pot_val, count = 0;
  11          char ball_1, ball_2 = 3;
  12          char xpos, ypos, xangle, yangle = 0;
  13          code unsigned char ball[] = {0x0E, 0x1F, 0x1F, 0x1F, 0x0E};
  14          code unsigned char sine[] = { 176, 217, 244, 254, 244, 217, 176, 128, 80, 39, 12, 2, 12, 39, 80, 128 };
  15          xdata unsigned char blocks_1[11][5] = {
  16                  {1, 1, 1, 1, 1},
  17                  {1, 1, 1, 1, 1},
  18                  {1, 1, 1, 1, 1},
  19                  {1, 1, 1, 1, 1},
  20                  {1, 1, 1, 1, 1},
  21                  {1, 1, 1, 1, 1},
  22                  {1, 1, 1, 1, 1},
  23                  {1, 1, 1, 1, 1},
  24                  {1, 1, 1, 1, 1},
  25                  {1, 1, 1, 1, 1},
  26                  {1, 1, 1, 1, 1}
  27              }; 
  28          xdata unsigned char blocks_2[11][5] = {
  29                  {1, 1, 1, 1, 1},
  30                  {1, 1, 1, 1, 1},
  31                  {1, 1, 1, 1, 1},
  32                  {1, 1, 1, 1, 1},
  33                  {1, 1, 1, 1, 1},
  34                  {1, 1, 1, 1, 1},
  35                  {1, 1, 1, 1, 1},
  36                  {1, 1, 1, 1, 1},
  37                  {1, 1, 1, 1, 1},
  38                  {1, 1, 1, 1, 1},
  39                  {1, 1, 1, 1, 1}
  40              };
  41          unsigned long sum = 0;
  42          sbit button = P2^6;
  43          ////////////////////////////////////////////////////////////////////////////////////
  44          //                                              Timer 4 Interupt: Used for Game audio
  45          //      Occurs when timer four flag is raised.
  46          //      This plays the sound bite for the desired duration.
  47          //      Audio is set up for certain frequencies and then played through this interupt.
  48          //
  49          ////////////////////////////////////////////////////////////////////////////////////
  50          
  51          unsigned char phase = sizeof(sine)-1;   // current point in sine to outputcode 
  52          
  53          unsigned int duration = 0;              // number of cycles left to output
  54          
  55          void timer4(void) interrupt 16
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 2   

  56          {
  57   1              T4CON = T4CON^0x80;
  58   1              DAC0H = sine[phase];
  59   1              if ( phase < sizeof(sine)-1 )   // if mid-cycle
  60   1              {                               
  61   2                      phase++;                                        // complete it
  62   2              }
  63   1              else if ( duration > 0 )        // if more cycles left to go
  64   1              {                               
  65   2                      phase = 0;                              // start a new cycle
  66   2                      duration--;
  67   2              }
  68   1              if (duration == 0){                     //Turn off timer when the sound is done
  69   2                      T4CON = 0x00;
  70   2                      }
  71   1      }
  72          
  73          ////////////////////////////////////////////////////////////////////////////////////
  74          //                                      Potentiometer Reading: Used for moving the paddle
  75          //      Occurs when ADC flag is raised and it samples the potentiometer.
  76          //      Takes several samples from the potentiometer and averages them.
  77          //
  78          ////////////////////////////////////////////////////////////////////////////////////
  79          void pot() interrupt 15{
  80   1              
  81   1              unsigned long samp = 0;
  82   1              unsigned int D;
  83   1              AD0INT = 0;
  84   1      
  85   1              D = (ADC0L|(ADC0H << 8)); //Takes in the Data from the potentiometer
  86   1              if(player == 0){
  87   2              samp = (89L - pad_w)*D/4096;    //This normalizes the sample to fit within the play area for player 1
  88   2              }
  89   1              else{
  90   2              samp = (89L - pad_w2)*D/4096;   //This normalizes the sample to fit within the play area for player 2
  91   2              }
  92   1              sum += samp;                                    //Takes the sum of 8 samples
  93   1              count++;
  94   1              
  95   1              if(count % 7 == 0)                              //after 8 samples take the average and update the potentiometers
  96   1              {
  97   2                      pot_val = sum >> 3;                     //bit shift for division
  98   2                      sum = 0;
  99   2              }
 100   1      
 101   1      }
 102          
 103          ////////////////////////////////////////////////////////////////////////////////////
 104          //                                              Displays Characters to Screen
 105          //      Input: 
 106          //              -Row: 0-7 On the screen
 107          //              -Col: 0-127 Desired column to start the character
 108          //              -single_char: One Keyboard character to be printed to the screen.
 109          //      Output:
 110          //              -Displays single character on the LCD display
 111          ////////////////////////////////////////////////////////////////////////////////////
 112          void disp_char(unsigned char row, unsigned char col, char single_char)
 113          {
 114   1              int i, j;
 115   1              unsigned char k;
 116   1              i = 128*row+col;                                //takes the row and column and translates it to the exact position on LCD
 117   1              j = (single_char - 0x20)*5;             //translates the single char to be comptible with the font function.
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 3   

 118   1              for(k = 0; k < 5; k ++) {
 119   2                      screen[i+k] = font5x8[j + k]; //calls font and prints the char
 120   2                      }
 121   1      }
 122          
 123          ////////////////////////////////////////////////////////////////////////////////////
 124          //                                              Displays Score to Screen
 125          //      Input: 
 126          //              -X: 0-7 row on the screen
 127          //              -Y: 0-127 Desired column to start the character
 128          //              -Score: Four digit score to be printed on the screen
 129          //      Output:
 130          //              -Displays entire score on the LCD display
 131          ////////////////////////////////////////////////////////////////////////////////////
 132          void disp_score(int x, int y, unsigned long score){
 133   1              int thou = 0;
 134   1              int hund = 0;
 135   1              int tens = 0;
 136   1              int ones = 0;
 137   1              thou = score/1000;      //takes the thousands place
 138   1              score = score%1000;     //remove the thousands place
 139   1              hund = score/100;       //takes the hundreds place
 140   1              score = score%100;      //remove the hundreds place
 141   1              tens =score/10;         //takes the tens place
 142   1              ones = score%10;        //takes the ones place
 143   1              disp_char(x, y, thou + '0');    //display thousands
 144   1              disp_char(x, y+6, hund + '0');  //display hundreds
 145   1              disp_char(x, y+12, tens + '0'); //display tens
 146   1              disp_char(x, y+18, ones + '0'); //display ones
 147   1      }
 148          
 149          ////////////////////////////////////////////////////////////////////////////////////
 150          //                                              Display configuration
 151          //      This function sets up the display area for the game. 
 152          //      Prints the boarders for the play area 79x62 with two bit boarder on the outside
 153          //      Displays high score, current player score, player 1's balls left,
 154          //      and player two's balls left.
 155          ////////////////////////////////////////////////////////////////////////////////////
 156          void display()
 157          {
 158   1              int i;
 159   1      
 160   1              if(score > high_score)  //updates high score if current score is greater
 161   1              {
 162   2                      high_score = score;     
 163   2              }
 164   1      
 165   1              
 166   1              for(i = 0; i < 82; i++)
 167   1              {
 168   2                      screen[i] |= 3;         //Prints the top boarder
 169   2              }
 170   1              for(i = 0; i < 8; i++)  //print the side walls
 171   1              {
 172   2                      screen[i*128] |= 255;           //255 is a full column on a page
 173   2                      screen[i*128 + 1] |= 255;       //left two boarders
 174   2                      screen[i*128 + 81] |= 255;      //right two boarders
 175   2                      screen[i*128 + 80] |= 255;
 176   2              }
 177   1      
 178   1              //All scores and player's balls are printed on the right side of the screen.
 179   1      
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 4   

 180   1              //Display High Score
 181   1              disp_char(0, 89, 'H');
 182   1              disp_char(0, 95, 'I');
 183   1              disp_char(0, 101, 'G');
 184   1              disp_char(0, 107, 'H');
 185   1              disp_char(0, 113, ':');
 186   1      
 187   1              disp_score(1, 93, high_score);
 188   1      
 189   1              //display current player's score
 190   1              disp_char(2, 87, 'S');
 191   1              disp_char(2, 93, 'C');
 192   1              disp_char(2, 99, 'O');
 193   1              disp_char(2, 105, 'R');
 194   1              disp_char(2, 111, 'E');
 195   1              disp_char(2, 117, ':');
 196   1              
 197   1              disp_score(3, 93, score);
 198   1              
 199   1              //Display player ones balls left
 200   1              disp_char(4, 99, 'P');
 201   1              disp_char(4, 105, '1');
 202   1              if(ball_1 == 3){
 203   2                      disp_char(5, 87, '*');
 204   2                      disp_char(5, 102, '*');
 205   2                      disp_char(5, 117, '*');
 206   2                      }
 207   1              else if (ball_1 == 2){
 208   2                      disp_char(5, 87, '*');
 209   2                      disp_char(5, 102, '*');
 210   2                      }
 211   1              else if(ball_1 == 1) {
 212   2                      disp_char(5, 87, '*');
 213   2                      }
 214   1      
 215   1              //If more than one player display player two's info
 216   1              if(num_player == 1)
 217   1              {
 218   2                      disp_char(6, 99, 'P');
 219   2                      disp_char(6, 105, '2');
 220   2              }
 221   1              if(ball_2 == 3){
 222   2                      disp_char(7, 87, '*');
 223   2                      disp_char(7, 102, '*');
 224   2                      disp_char(7, 117, '*');
 225   2                      }
 226   1              else if (ball_2 == 2){
 227   2                      disp_char(7, 87, '*');
 228   2                      disp_char(7, 102, '*');
 229   2                      }
 230   1              else if(ball_2 == 1) {
 231   2                      disp_char(7, 87, '*');
 232   2                      }
 233   1      
 234   1              //Displays "-P*-" according to who's turn it is
 235   1              if(player == 0)
 236   1              {
 237   2                      disp_char(4, 93, '-');
 238   2                      disp_char(4, 111, '-');
 239   2              }
 240   1              else
 241   1              {
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 5   

 242   2                      disp_char(6, 93, '-');
 243   2                      disp_char(6, 111, '-');
 244   2              }
 245   1      
 246   1              //displays the screen
 247   1              refresh_screen();
 248   1      }
 249          
 250          ////////////////////////////////////////////////////////////////////////////////////
 251          //                                              Wait Screen
 252          //      This function displays a screen in between players turns.
 253          //      Prints "Player *current player* Ready" 
 254          //      Resets the speed and starts the ball in the middle of the screen.
 255          //      Waits for the player to press the start button.
 256          ////////////////////////////////////////////////////////////////////////////////////
 257          void wait_screen(){
 258   1              
 259   1              TR2 = 0;        //stops the clock
 260   1              xpos = 40;      //middle of screen
 261   1              ypos = 40;      //one pixel below the bricks
 262   1              xangle = 1;     //resets xangle 
 263   1              yangle = 1;     //resets yangle
 264   1              blank_screen();
 265   1              
 266   1              //Display "Player (current player) Ready"
 267   1              disp_char(2, 24, 'P');
 268   1              disp_char(2, 30, 'L');
 269   1              disp_char(2, 36, 'A');
 270   1              disp_char(2, 42, 'Y');
 271   1              disp_char(2, 48, 'E');
 272   1              disp_char(2, 54, 'R');
 273   1      
 274   1              if(player == 0){
 275   2                      disp_char(3, 36, 'O');
 276   2                      disp_char(3, 42, 'N');
 277   2                      disp_char(3, 48, 'E');
 278   2              }
 279   1              else{
 280   2                      disp_char(3, 36, 'T');
 281   2                      disp_char(3, 42, 'W');
 282   2                      disp_char(3, 48, 'O');
 283   2              }
 284   1              disp_char(4, 30, 'R');
 285   1              disp_char(4, 36, 'E');
 286   1              disp_char(4, 42, 'A');
 287   1              disp_char(4, 48, 'D');
 288   1              disp_char(4, 54, 'Y');
 289   1      
 290   1              display();      //Display boarders and scores
 291   1              
 292   1              //Checks if both players lives are at 3 if so it's the start of the game
 293   1              if(ball_1 == 3 && ball_2 == 3){ 
 294   2                      while (button == 1){
 295   3                      pad_w = P1&3;   //set player1 paddle size with switches (1 and 2)
 296   3                      pad_w2 = P1&96; //set player2 paddle size with switches (6 and 7)
 297   3                      pad_w2 = pad_w2 >>5; //shift player2 so that it is between 0 to 3
 298   3      
 299   3                      //sets the initial speed of the ball 
 300   3                      t_cnt_init = P1&24; //switches 4 and 5
 301   3                      t_cnt_init = t_cnt_init >>3; //shift so it's between 0 to 3
 302   3                      
 303   3                      num_player = player_sw; //One or two players based on switch 8;
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 6   

 304   3                      
 305   3                      }
 306   2      
 307   2                      //sets the paddle width for 24, 16, 12, and 8 bits
 308   2                      if(pad_w == 3){
 309   3                              pad_w = 24;
 310   3                      }
 311   2                      else{
 312   3                              pad_w = pad_w2*4 +8; //(0 to 2)*4 +8 = 16-8 
 313   3                      }
 314   2                      if(pad_w2 == 3){
 315   3                              pad_w2 = 24;
 316   3                      }
 317   2                      else{
 318   3                              pad_w2 = pad_w2*4 +8; //(0 to 2)*4 +8 = 16-8
 319   3                      }
 320   2                      
 321   2                      //initialize speed of the ball
 322   2                      t_cnt_init = t_cnt_init*10 + 30; //(0 t0 3)*10 + 30 = 30 - 60
 323   2                      t_cnt = t_cnt_init;                             //set current count to the inital
 324   2                      if(num_player == 0){
 325   3                      ball_2 = 0; //no two player remove their lives
 326   3                      }
 327   2              }
 328   1              else{
 329   2                      while (button == 1){}; //wait till button is pressed
 330   2              }
 331   1              TR2 = 1;        //turn timer back on
 332   1      }
 333          
 334          ////////////////////////////////////////////////////////////////////////////////////
 335          //                                              Game Over Screen
 336          //      This function displays a screen at the end of the game
 337          //      Prints "GAME OVER" 
 338          //      Waits for the reset button to be pressed
 339          ////////////////////////////////////////////////////////////////////////////////////
 340          void game_over()
 341          {
 342   1              TR2 = 0; //turn timer off
 343   1      
 344   1              blank_screen(); //clear screen
 345   1              //print Game Over
 346   1              disp_char(2, 30, 'G');
 347   1              disp_char(2, 36, 'A');
 348   1              disp_char(2, 42, 'M');
 349   1              disp_char(2, 48, 'E');
 350   1              disp_char(3, 30, 'O');
 351   1              disp_char(3, 36, 'V');
 352   1              disp_char(3, 42, 'E');
 353   1              disp_char(3, 48, 'R');
 354   1      
 355   1              display(); //display boarders and scores
 356   1              while(1){} //Stays until board is reset
 357   1              
 358   1      }
 359          
 360          ////////////////////////////////////////////////////////////////////////////////////
 361          //                                              Turn Over Screen
 362          //      This function displays a screen at the end of one players turn
 363          //      Switches variables for the next player and checks the end game condition 
 364          //      Sends player to the wait screen or game over screen
 365          ////////////////////////////////////////////////////////////////////////////////////
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 7   

 366          void turn_end()
 367          {
 368   1              //Audio for ball touching the bottom
 369   1              RCAP4H = -1763>>8;                      // set up for 784Hz
 370   1              RCAP4L = -1763;                         // set up for 784 Hz
 371   1              duration = 196;                         // quarter second
 372   1              T4CON = T4CON^0x04;                     //enable timer 4
 373   1              
 374   1              //speed reset
 375   1              su = 0;                                 //reset speed up for 3rd brick                  
 376   1              t_cnt = t_cnt_init;             //reset speed to original speed
 377   1              
 378   1              //Check if it's a two player game
 379   1              if(num_player == 1){
 380   2                      //if it was the first players turn and they lost
 381   2                      if(player == 0){
 382   3                              ball_1 = ball_1 -1;     //decrease lives by one
 383   3                              player = 1;                     //set player to second player
 384   3                              score_1 = score;        //Save player One's current score
 385   3                              score = score_2;        //Set the score to player two's
 386   3                      }
 387   2      
 388   2                      //if it was the second players turn and they lost
 389   2                      else{
 390   3                              //check game over condition no more lives left
 391   3                              if(ball_2 == 1){
 392   4                                      ball_2 -= 1;
 393   4                                      game_over();}
 394   3                              
 395   3                              else{
 396   4                                      ball_2 = ball_2 -1;     //decrease lives by one
 397   4                                      player = 0;                     //set player to first player
 398   4                                      score_2 = score;        //Save player Two's current score
 399   4                                      score = score_1;        //Set the score to player One's
 400   4                              }
 401   3                      }
 402   2              }
 403   1              //If it's a single player game
 404   1              else{
 405   2                      if(ball_1 == 1){ //Check for a game over
 406   3                              game_over();}
 407   2                      else{
 408   3                              ball_1 = ball_1 -1; //Decrease lives
 409   3                              }
 410   2              }
 411   1              wait_screen(); //Send to wait screen
 412   1      }
 413          
 414          ////////////////////////////////////////////////////////////////////////////////////
 415          //                                              Draw the Bricks
 416          //      This function takes the arrays of bricks and draws them accordingly on the
 417          //      screen. A one represents a brick to be drawn and a zero represents a brick to 
 418          //      be deleted. Bricks are 11x5
 419          ////////////////////////////////////////////////////////////////////////////////////
 420          void draw_bricks(){
 421   1              int i;
 422   1              int j;
 423   1              int k;
 424   1              int zero_cnt = 0;
 425   1              xdata unsigned char blocks[11][5] = {0};
 426   1              
 427   1              //Sets the bricks to be drawn dependent on the player
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 8   

 428   1              if(player == 0)
 429   1              {
 430   2                      for(i= 0; i < 11; i ++)
 431   2                      {
 432   3                              for(j = 0; j < 5; j ++)
 433   3                              {
 434   4                                      blocks[i][j] = blocks_1[i][j];
 435   4                              }
 436   3                      }               
 437   2              }
 438   1              else
 439   1              {
 440   2                      for(i= 0; i < 11; i ++)
 441   2                      {
 442   3                              for(j = 0; j < 5; j ++)
 443   3                              {
 444   4                                      blocks[i][j] = blocks_2[i][j];
 445   4                              }
 446   3                      }       
 447   2              }
 448   1              
 449   1              //Loops through the bricks and draws them or deletes them from the screen
 450   1              for(i= 0; i < 11; i ++)
 451   1              {
 452   2                      for(j = 0; j < 5; j ++)
 453   2                      {
 454   3                              if(blocks[i][j] == 1) //If there is a block at this location
 455   3                              {
 456   4                                      if(j%2 == 1) //If y value is even draw on the first half of the page
 457   4                                      {
 458   5                                              for(k = 0; k < 6; k++) //draws the brick 6 wide
 459   5                                              {
 460   6                                                      screen[((j-1)/2)*128 + i*7 +k +131] |= 0x70; //Three bits at the top of the page with one space on t
             -op
 461   6                                                      //((j-1)/2)*128 = row to print, i*7 +131 = column, +k does it 6 times for the brick
 462   6                                              }
 463   5                                      }
 464   4                                      else //If y value is odd draw on the second half of the page
 465   4                                      {
 466   5                                              for(k = 0; k < 6; k++) //draws the brick 6 wide
 467   5                                              {
 468   6                                                      screen[(j/2)*128 + i*7 + k +131] |= 0x07; //Three bits on the bottom of the page with one top space
 469   6                                                      //((j/2)*128 = row to print, i*7 +131 = column, +k does it 6 times for the brick
 470   6                                              }
 471   5                                      }
 472   4                              }
 473   3                              else
 474   3                              {
 475   4                                      zero_cnt ++; //keeps track of the cleared bricks allowing the screen to repopulate at 55
 476   4                                      if(j%2 == 1)
 477   4                                      {
 478   5                                              for(k = 0; k < 6; k++)
 479   5                                              {
 480   6                                                      screen[(j-1)/2*128 + i*7 + k + 131] &= 0x07; //ands the top with zero to clear desired brick
 481   6                                                      //see above for math of drawing blocks
 482   6                                                      
 483   6                                              }
 484   5                                      }
 485   4                                      else
 486   4                                      {
 487   5                                              for(k = 0; k < 6; k++)
 488   5                                              {
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 9   

 489   6                                                      screen[j/2*128 + i*7 + k + 131] &= 0x70;        //ands the bottom with zero to clear desired brick
 490   6                                                      //see above for math of drawing blocks
 491   6                                              }
 492   5                                      }
 493   4                              }
 494   3                      }
 495   2              }
 496   1              if(zero_cnt == 55 && ypos > 40){        //Check if all the blocks have been cleared
 497   2                      if(player == 0) //reset bricks of player 1
 498   2                      {
 499   3                              for(i= 0; i < 11; i ++)
 500   3                              {
 501   4                                      for(j = 0; j < 5; j ++)
 502   4                                      {
 503   5                                      blocks_1[i][j] = 1; //loops and sets each value to one
 504   5                                      }
 505   4                              }               
 506   3                      }
 507   2                      else //reset bricks of player 2
 508   2                      {
 509   3                              for(i= 0; i < 11; i ++)
 510   3                              {
 511   4                                      for(j = 0; j < 5; j ++)
 512   4                                      {
 513   5                                      blocks_2[i][j] = 1;     //loops and sets each value to one
 514   5                                      }
 515   4                              }       
 516   3                      }
 517   2              } 
 518   1      }
 519          
 520          ////////////////////////////////////////////////////////////////////////////////////
 521          //                                              Draw the Paddle
 522          //      This function takes the current pot value passed in and draws the paddle
 523          //      according to the paddle width selected. 
 524          //      
 525          ////////////////////////////////////////////////////////////////////////////////////
 526          void draw_paddle(char x)
 527          {
 528   1              int i;
 529   1              int padd_w;
 530   1      
 531   1              //Sets padd_w depending on who's turn it is
 532   1              if(player == 0){
 533   2                      padd_w = (int)pad_w;
 534   2                      
 535   2              }
 536   1              else{
 537   2                      padd_w = (int)pad_w2;
 538   2              }
 539   1      
 540   1              //Draw the paddle
 541   1              for(i = 0; i < padd_w; i ++)
 542   1                      {
 543   2                              screen[898+x+i] |= 0xc0; //898 is the bottom left corner of the play area 0xc0 is a paddle 2 bits thick
 544   2                              //x offsets the paddle to the knob position, i then draws the paddle padd_w wide.
 545   2                      }
 546   1      }
 547          
 548          ////////////////////////////////////////////////////////////////////////////////////
 549          //                                              Draw the Ball
 550          //      This function does a lot:
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 10  

 551          //              -Draws the ball
 552          //              -Bounces the ball off walls
 553          //              -Bounces the ball off the paddle
 554          //                      -changes angle based on bounce off paddle
 555          //              -Detects hits on bricks and breaks the corressponding brick
 556          //              -Returns a hit code that determines which audio is played
 557          //      
 558          ////////////////////////////////////////////////////////////////////////////////////
 559          unsigned char draw_ball(int x, int y)
 560          {       unsigned char row, col, shift, j, hit;
 561   1              int i;
 562   1              
 563   1              col = x-2; //correct for center of ball
 564   1              row = y - 2; //correct for center of ball
 565   1              shift = row%8;
 566   1              row = row/8;
 567   1              hit = 0; //initialize hit to zero
 568   1              
 569   1              //draw the ball and return a value greater than zero if a hit occurs
 570   1              for(j = 0, i = row*128+col; j < 5; i++, j++)
 571   1              {
 572   2                      int mask = (int)ball[j] << shift;
 573   2                      hit |= screen[i]&(unsigned char)mask;
 574   2                      screen[i] |= mask;
 575   2      
 576   2                      if(mask & 0xFF00)
 577   2                      {
 578   3                              hit |= screen[i+128]&(unsigned char)(mask >> 8);
 579   3                              screen[i + 128] |= (unsigned char)(mask >> 8);
 580   3                      }
 581   2              }
 582   1      
 583   1              //Checks if the ball is gonna hit the corner of the screen and inverts both angles
 584   1              if((x<5 || x > 78) && y < 3)
 585   1              {
 586   2                      yangle = -1*yangle;
 587   2                      xangle = -1*xangle;
 588   2                      return -2;//audio code
 589   2              }
 590   1              //checks the left and right edges of the screen and inverts xangle if hit
 591   1              else if(x<5 || x > 78)
 592   1              {
 593   2                      xangle = -1*xangle;
 594   2                      return -2;//audio code
 595   2              }
 596   1              //checks the top of the play area and inverts y if hit
 597   1              else if (y < 3)
 598   1              {
 599   2                      yangle = -1*yangle;
 600   2                      return -2;//audio code
 601   2              }
 602   1              //checks the bottom of the screen and ends the game if hit
 603   1              else if(y > 61)
 604   1              {
 605   2                      turn_end();
 606   2                      return -3;
 607   2              }
 608   1      
 609   1              //Paddle hit detection and subsequent angle configs for different parts of the paddle.
 610   1              //This code devides the paddle into 4 sections and returns the angle as needed
 611   1              if( y == 60 && hit > 0){        //The only place the ball can hit the paddle is at y = 60 and if the ball detect
             -ed a hit that means it hit the paddle
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 11  

 612   2      
 613   2                      char col = xpos - pot_val -2; //takes xposition of the ball subtracts the pot val and -2 to tell where t
             -he ball is in relation to the paddle
 614   2                      int div = 0;
 615   2                      //Calculates the paddle division based on player and the size of their paddle.
 616   2                      if(player == 0){
 617   3                              div = pad_w/4;  //paddle separated into four sections
 618   3                              }
 619   2                      else{
 620   3                              div = pad_w2/4; //paddle separated into four sections
 621   3                              }
 622   2                      if( col < div || col > 3*div) //did the ball hit the outside quarters of the paddle?
 623   2                      {
 624   3                              xangle = 2; //If so return a steeper angle
 625   3                              yangle = -1;
 626   3                      }
 627   2                      else
 628   2                      {
 629   3                              xangle = 1; //If it hit the center return a shallower angle
 630   3                              yangle = -2;
 631   3                      }
 632   2                      if(col < div *2) //did the ball hit the left side of the paddle?
 633   2                      {
 634   3                              xangle = -1*xangle; //If so send the ball to the left
 635   3                      }
 636   2                      return -1;//audio code
 637   2              }
 638   1              
 639   1              //All brick breaking logic, if it didn't hit the paddle or the sides, you hit a brick
 640   1              else if( hit > 0)
 641   1              {
 642   2                      
 643   2                      int x_b, y_b;
 644   2                      score += 1; //hit a brick increase the score!
 645   2      
 646   2                      //Normalize the y_position to return a value inside of brick matrix = (ypos -8)/4
 647   2                      //Normalize the x_position to return a value inside of brick matrix = (xpos -3)/7
 648   2                      if(yangle < 0)
 649   2                      {
 650   3                              y_b = (ypos -10)/4; //ball is moving up so normalize to the top edge of the ball with extra -2
 651   3                      }
 652   2                      else{
 653   3                              y_b = (ypos -6)/4;      //ball is moving down so normalize to the bottom edge of the ball with extra +2
 654   3                      }
 655   2                      if(xangle < 0)
 656   2                      {
 657   3                              x_b = (xpos -5)/7; //ball is moving left so normalize to the left edge of the ball with extra -2
 658   3                      }
 659   2                      else
 660   2                      {
 661   3                              x_b = (xpos -1)/7;      //ball is moving right so normalize to the right edge of the ball with extra +2
 662   3                      }
 663   2      
 664   2                      if(y_b > 4 || x_b > 10){ //If the x_b and y_b positions aren't in the bounds of the matrix ignore it
 665   3                      }
 666   2                      
 667   2                      //Update players bricks according to the brick that was hit     
 668   2                      else if(player == 0)
 669   2                      {
 670   3                              if(blocks_1[x_b][y_b] == 0) //Check if the current index of the ball has a brick in it, if not it's pro
             -bably on one of the sides
 671   3                                      {
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 12  

 672   4                                              if(xangle < 0) //ball is moving left so delete the ball to the left
 673   4                                                      {
 674   5                                                              y_b = (ypos -8)/4;      //Normalize position to the center ball 
 675   5                                                              blocks_1[x_b-1][y_b] = 0; //delete the ball to the left
 676   5                                                      }
 677   4                                              else
 678   4                                                      {
 679   5                                                              y_b = (ypos -8)/4;      //Normalize position to the center ball
 680   5                                                              blocks_1[x_b+1][y_b] = 0;       //delete the ball to the left
 681   5                                                      }
 682   4                                              xangle = -1*xangle;     //bounce the ball to the side
 683   4                                      }
 684   3                              else
 685   3                              {
 686   4                                              blocks_1[x_b][y_b] = 0;//brick hit the top, delete that brick
 687   4                                              yangle = -1*yangle; //bounce the ball up or down
 688   4                              }
 689   3                      }
 690   2                      //Same logic described above is used for player 2's bricks
 691   2                      else if(player == 1)
 692   2                      {
 693   3                              if(blocks_2[x_b][y_b] == 0)
 694   3                              {
 695   4                                      if(xangle < 0)
 696   4                                      {
 697   5                                              y_b = (ypos -8)/4;
 698   5                                              blocks_2[x_b-1][y_b] = 0;
 699   5                                      }
 700   4                                      else
 701   4                                      {
 702   5                                              y_b = (ypos -8)/4;
 703   5                                              blocks_2[x_b+1][y_b] = 0;
 704   5                                      }
 705   4                                              xangle = -1*xangle;
 706   4                              }
 707   3                              else
 708   3                              {       
 709   4                                      if(x_b >= 0 || y_b >= 0){
 710   5                                              blocks_2[x_b][y_b] = 0;
 711   5                                              yangle = -1*yangle;
 712   5                                      }
 713   4                              }       
 714   3                      }
 715   2      
 716   2                      //checks if the ball is hitting the third row of bricks for the first time
 717   2                      if(hit > 0 && ypos <= 21 && su ==0) //21 is the first row in which the ball could hit the 3rd row of bri
             -cks
 718   2                      {
 719   3                              t_cnt = t_cnt*0.6; //speed up the ball movement by a factor of .4
 720   3                              su = 1;                         //set the flag so it doesn't continuously speed up
 721   3                      }
 722   2              }
 723   1              return hit; //return hit value mainly used for audio que
 724   1      }
 725          
 726          ////////////////////////////////////////////////////////////////////////////////////
 727          //                                              Move the Ball
 728          //      This function updates the balls postition based on the current x and y angle
 729          //      and then calls draw ball and stores the audio que in a variable called bonk
 730          //      
 731          ////////////////////////////////////////////////////////////////////////////////////
 732          void mov_ball() {
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 13  

 733   1              xpos += xangle; //update xpos by xangle
 734   1              ypos += yangle; //update ypos by yangle
 735   1              bonk = draw_ball(xpos, ypos);   //saves audio code in bonk and draws the ball
 736   1              display();      //update the display
 737   1      }
 738          
 739          ////////////////////////////////////////////////////////////////////////////////////
 740          //                                              Timer2 Interrupt
 741          //      This interrupt updates the int_cnt which will determine how often the ball 
 742          //      is updated and drawn which in turn effects the speed of the ball.
 743          //      
 744          ////////////////////////////////////////////////////////////////////////////////////
 745          void timer2(void) interrupt 5
 746          {
 747   1              
 748   1              TF2 = 0;        //reset the timer flag 
 749   1              int_cnt ++;     //increase the timer count 
 750   1                      
 751   1      }
 752          
 753          
 754          
 755          
 756          
 757          void main()
 758          {
 759   1              WDTCN = 0xde; //disable watchdog
 760   1              WDTCN = 0xad;
 761   1              XBR2 = 0x40;  //port output
 762   1              OSCXCN = 0x67; //crystal enabled
 763   1              TMOD = 0x20;  //wait 1ms: T1 mode 2
 764   1              TH1 = 167;        // 1ms/(1/(2Mhz/12)) = 166.666
 765   1              TR1 = 1;          //enable timer 1
 766   1              while( TF1 == 0) {}     //1 ms wait for flag
 767   1              while( !(OSCXCN & 0x80)) {} //stabilize crystal
 768   1              OSCICN = 8;   // switch to 22.1184Mhz
 769   1              
 770   1              IE = 0xA0;       //Timer 2 interrupt enable
 771   1              EIE2 = 0x06; //Timer 4 and ADC
 772   1              
 773   1              T4CON = 0x00; //timer 4, auto reload
 774   1              RCAP4H = -1;    //timer 4
 775   1              RCAP4L = -144;  //timer 4
 776   1              DAC0CN = 0x9C;  //Speaker setup
 777   1      
 778   1              T2CON = 0x00;   //set up timer 2
 779   1              RCAP2H = -2211 >> 8;    
 780   1              RCAP2L = -2211;
 781   1      
 782   1              ADC0CN = 0x8c;  //configure the ADC for the potentiometer
 783   1              REF0CN = 0x07;
 784   1              ADC0CF = 0x40;  //Configure the ADC for the audio
 785   1              AMX0SL = 0x0;
 786   1              CKCON = 0x40;   //Turn off divide by 12 for timer 4
 787   1      
 788   1              TR2 = 1;                        //Turn on Timer 2
 789   1              T4CON = T4CON^0x04; //Turn on Timer 4
 790   1              
 791   1              init_lcd();     //initalize the LCD
 792   1              xpos = 40;//middle of screen
 793   1              ypos = 40;//one pixel below the bricks
 794   1      
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/22/2024 00:11:13 PAGE 14  

 795   1      
 796   1              display(); //update display
 797   1              wait_screen(); //send game to wait for start
 798   1              
 799   1              
 800   1              
 801   1              
 802   1              while(1)
 803   1              {
 804   2                      if(int_cnt==t_cnt) //check the clock's count with the desired update count
 805   2                      {
 806   3                              //Main gameplay loop
 807   3                              blank_screen();                 //blank screen
 808   3                              draw_paddle(pot_val);   //update the paddle
 809   3                              draw_bricks();                  //update bricks
 810   3                              mov_ball();                             //move the ball
 811   3                              int_cnt = 0;                    //reset the count
 812   3      
 813   3                              //Audio setup for brick breaking
 814   3                              if(bonk > 0){
 815   4                                      RCAP4H = -2097 >> 8;            // set up for 659Hz
 816   4                                      RCAP4L = -2097;                         // set up for 659Hz
 817   4                                      duration = 165;                         //quarter second
 818   4                                      T4CON = T4CON^0x04;                     //enable timer 4
 819   4                              }
 820   3                              //Audio for bouncing off paddle
 821   3                              else if(bonk ==-1)
 822   3                              {
 823   4                                      RCAP4H = -2642 >> 8;            // set up for 523Hz
 824   4                                      RCAP4L = -2642;                         // set up for 523Hz
 825   4                                      duration = 131;                         //quarter second
 826   4                                      T4CON = T4CON^0x04;                     //enable timer 4
 827   4                              }
 828   3                              //Audio for bouncing off wall
 829   3                              else if(bonk == -2)
 830   3                              {
 831   4                                      RCAP4H = -2354>>8;                      // set up for 587Hz
 832   4                                      RCAP4L = -2354;                         // set up for 587Hz
 833   4                                      duration = 147;                         //quarter second
 834   4                                      T4CON = T4CON^0x04;                     //enable timer 4
 835   4                              }
 836   3                      }
 837   2              }
 838   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4057    ----
   CONSTANT SIZE    =     76    ----
   XDATA SIZE       =    110      55
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     45      47
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
