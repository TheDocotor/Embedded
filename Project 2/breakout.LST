C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BREAKOUT
OBJECT MODULE PLACED IN breakout.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe breakout.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          #include <c8051f020.h>
   2          #include <lcd.h>
   3          #include<stdio.h>
   4          #include<stdlib.h>
   5           
   6          long score_2, score, score_1, high_score = 0;
   7          sbit player_sw = P1^7;
   8          char switches, bonk = 0; 
   9          bit player, num_player = 0;
  10          int int_cnt, t_cnt, t_cnt_init, pad_w, pot_val, count = 0;
  11          char ball_1, ball_2 = 3;
  12          char xpos, ypos, xangle, yangle = 0;
  13          code unsigned char ball[] = {0x0E, 0x1F, 0x1F, 0x1F, 0x0E};
  14          code unsigned char sine[] = { 176, 217, 244, 254, 244, 217, 176, 128, 80, 39, 12, 2, 12, 39, 80, 128 };
  15          xdata unsigned char blocks_1[11][5] = {
  16                  {1, 1, 1, 1, 1},
  17                  {1, 1, 1, 1, 1},
  18                  {1, 1, 1, 1, 1},
  19                  {1, 1, 1, 1, 1},
  20                  {1, 1, 1, 1, 1},
  21                  {1, 1, 1, 1, 1},
  22                  {1, 1, 1, 1, 1},
  23                  {1, 1, 1, 1, 1},
  24                  {1, 1, 1, 1, 1},
  25                  {1, 1, 1, 1, 1},
  26                  {1, 1, 1, 1, 1}
  27              }; 
  28          xdata unsigned char blocks_2[11][5] = {
  29                  {1, 1, 1, 1, 1},
  30                  {1, 1, 1, 1, 1},
  31                  {1, 1, 1, 1, 1},
  32                  {1, 1, 1, 1, 1},
  33                  {1, 1, 1, 1, 1},
  34                  {1, 1, 1, 1, 1},
  35                  {1, 1, 1, 1, 1},
  36                  {1, 1, 1, 1, 1},
  37                  {1, 1, 1, 1, 1},
  38                  {1, 1, 1, 1, 1},
  39                  {1, 1, 1, 1, 1}
  40              };
  41          unsigned long sum = 0;
  42          sbit button = P2^6;
  43          
  44          void disp_char(unsigned char row, unsigned char col, char single_char);
  45          void disp_score(int x, int y, unsigned long score);
  46          void display();
  47          void mov_ball();
  48          unsigned char draw_ball(int x, int y);
  49          void wait_screen();
  50          void game_over();
  51          void turn_end();
  52          void draw_paddle(char x, char padd_w);
  53          
  54          //void adc_init(){
  55          //      REF0CN = 0x7;
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 2   

  56          //      ADC0CF = 0x40;
  57          //      ADC0CN = 0x8C;
  58          //      AMX0SL = 0;
  59          //}
  60          unsigned char phase = sizeof(sine)-1;   // current point in sine to output
  61          
  62          unsigned int duration = 0;              // number of cycles left to output
  63          
  64          void timer4(void) interrupt 16
  65          {
  66   1              T4CON = T4CON^0x80;
  67   1              DAC0H = sine[phase];
  68   1              if ( phase < sizeof(sine)-1 )   // if mid-cycle
  69   1              {                               // complete it
  70   2                      phase++;
  71   2              }
  72   1              else if ( duration > 0 )        // if more cycles left to go
  73   1              {                               // start a new cycle
  74   2                      phase = 0;
  75   2                      duration--;
  76   2              }
  77   1              if (duration == 0){
  78   2                      T4CON = 0x00;
  79   2                      }
  80   1      }
  81          
  82          void pot() interrupt 15{
  83   1              
  84   1              unsigned long samp = 0;
  85   1              unsigned int D;
  86   1              AD0INT = 0;
  87   1      
  88   1              D = (ADC0L|(ADC0H << 8));
  89   1      
  90   1              samp = (89L - pad_w)*D/4096;
  91   1              sum += samp;
  92   1              count++;
  93   1              
  94   1              if(count % 7 == 0)
  95   1              {
  96   2                      pot_val = sum >> 3;
  97   2                      sum = 0;
  98   2              }
  99   1      
 100   1      }
 101          
 102          void disp_char(unsigned char row, unsigned char col, char single_char)
 103          {
 104   1              int i, j;
 105   1              unsigned char k;
 106   1              i = 128*row+col;
 107   1              j = (single_char - 0x20)*5;
 108   1              for(k = 0; k < 5; k ++) {
 109   2                      screen[i+k] = font5x8[j + k];
 110   2                      }
 111   1      }
 112          
 113          void disp_score(int x, int y, unsigned long score){
 114   1              int thou = 0;
 115   1              int hund = 0;
 116   1              int tens = 0;
 117   1              int ones = 0;
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 3   

 118   1              thou = score/1000;
 119   1              score = score%1000;
 120   1              hund = score/100;
 121   1              score = score%100;
 122   1              tens =score/10;
 123   1              ones = score%10;
 124   1              disp_char(x, y, thou + '0');
 125   1              disp_char(x, y+6, hund + '0');
 126   1              disp_char(x, y+12, tens + '0');
 127   1              disp_char(x, y+18, ones + '0');
 128   1      }
 129          
 130          void display()
 131          {
 132   1              int i;
 133   1      
 134   1              if(score > high_score)
 135   1              {
 136   2                      high_score = score;
 137   2              }
 138   1      
 139   1              
 140   1              for(i = 0; i < 82; i++)
 141   1              {
 142   2                      screen[i] |= 3;
 143   2              }
 144   1              for(i = 0; i < 8; i++)
 145   1              {
 146   2                      screen[i*128] |= 255;
 147   2                      screen[i*128 + 1] |= 255;
 148   2                      screen[i*128 + 81] |= 255;
 149   2                      screen[i*128 + 80] |= 255;
 150   2              }
 151   1              disp_char(0, 89, 'H');
 152   1              disp_char(0, 95, 'I');
 153   1              disp_char(0, 101, 'G');
 154   1              disp_char(0, 107, 'H');
 155   1              disp_char(0, 113, ':');
 156   1      
 157   1              disp_score(1, 93, high_score);
 158   1      
 159   1              disp_char(2, 87, 'S');
 160   1              disp_char(2, 93, 'C');
 161   1              disp_char(2, 99, 'O');
 162   1              disp_char(2, 105, 'R');
 163   1              disp_char(2, 111, 'E');
 164   1              disp_char(2, 117, ':');
 165   1              
 166   1              //update for two players
 167   1              disp_score(3, 93, score);
 168   1      
 169   1              disp_char(4, 99, 'P');
 170   1              disp_char(4, 105, '1');
 171   1              if(ball_1 == 3){
 172   2                      disp_char(5, 87, '*');
 173   2                      disp_char(5, 102, '*');
 174   2                      disp_char(5, 117, '*');
 175   2                      }
 176   1              else if (ball_1 == 2){
 177   2                      disp_char(5, 87, '*');
 178   2                      disp_char(5, 102, '*');
 179   2                      }
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 4   

 180   1              else if(ball_1 == 1) {
 181   2                      disp_char(5, 87, '*');
 182   2                      }
 183   1              if(num_player == 1)
 184   1              {
 185   2                      disp_char(6, 99, 'P');
 186   2                      disp_char(6, 105, '2');
 187   2              }
 188   1              if(ball_2 == 3){
 189   2                      disp_char(7, 87, '*');
 190   2                      disp_char(7, 102, '*');
 191   2                      disp_char(7, 117, '*');
 192   2                      }
 193   1              else if (ball_2 == 2){
 194   2                      disp_char(7, 87, '*');
 195   2                      disp_char(7, 102, '*');
 196   2                      }
 197   1              else if(ball_2 == 1) {
 198   2                      disp_char(7, 87, '*');
 199   2                      }
 200   1      
 201   1              //potentially update player scores here
 202   1              if(player == 0)
 203   1              {
 204   2                      disp_char(4, 93, '-');
 205   2                      disp_char(4, 111, '-');
 206   2              }
 207   1              else
 208   1              {
 209   2                      disp_char(6, 93, '-');
 210   2                      disp_char(6, 111, '-');
 211   2              }
 212   1      
 213   1              refresh_screen();
 214   1      }
 215          
 216          void wait_screen(){
 217   1              TR2 = 0;
 218   1              xpos = 40;//middle of screen
 219   1              ypos = 40;//one pixel below the bricks
 220   1              xangle = 1;
 221   1              yangle = 1;
 222   1              blank_screen();
 223   1              
 224   1              
 225   1              disp_char(2, 30, 'P');
 226   1              disp_char(2, 36, 'R');
 227   1              disp_char(2, 42, 'E');
 228   1              disp_char(2, 48, 'S');
 229   1              disp_char(2, 54, 'S');
 230   1              disp_char(3, 30, 'S');
 231   1              disp_char(3, 36, 'T');
 232   1              disp_char(3, 42, 'A');
 233   1              disp_char(3, 48, 'R');
 234   1              disp_char(3, 54, 'T');
 235   1              //refresh_screen();
 236   1              display();
 237   1              if(ball_1 == 3 && ball_2 == 3){ 
 238   2                      while (button == 1){
 239   3                      pad_w = P1&3;
 240   3                      t_cnt_init = P1&24;
 241   3                      t_cnt_init = t_cnt_init >>3;
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 5   

 242   3                      num_player = player_sw;
 243   3                      
 244   3                              }
 245   2                      if(pad_w == 3){
 246   3                              pad_w = 24;
 247   3                      }
 248   2                      else{
 249   3                              pad_w = pad_w*4 +8;
 250   3                      }
 251   2                      t_cnt_init = t_cnt_init*10 + 30; 
 252   2                      t_cnt = t_cnt_init;
 253   2                      if(num_player == 0){
 254   3                      ball_2 = 0;
 255   3                      }
 256   2              }
 257   1              else{
 258   2                      while (button == 1){};
 259   2              }
 260   1              TR2 = 1;        
 261   1      }
 262          
 263          
 264          void game_over()
 265          {
 266   1              TR2 = 0;
 267   1      
 268   1              blank_screen();
 269   1              disp_char(2, 30, 'G');
 270   1              disp_char(2, 36, 'A');
 271   1              disp_char(2, 42, 'M');
 272   1              disp_char(2, 48, 'E');
 273   1              disp_char(3, 30, 'O');
 274   1              disp_char(3, 36, 'V');
 275   1              disp_char(3, 42, 'E');
 276   1              disp_char(3, 48, 'R');
 277   1      
 278   1              display();
 279   1              while(1){}
 280   1              
 281   1      }
 282          
 283          void turn_end()
 284          {
 285   1              t_cnt = t_cnt_init;
 286   1              if(num_player == 1){
 287   2                      
 288   2                      if(player == 0){
 289   3                              ball_1 = ball_1 -1;
 290   3                              player = 1;
 291   3                              score_1 = score;
 292   3                              score = score_2;
 293   3                      }
 294   2                      else{
 295   3                              if(ball_2 == 1){
 296   4                                      ball_2 -= 1;
 297   4                                      game_over();}
 298   3                              else{
 299   4                                      ball_2 = ball_2 -1;
 300   4                                      player = 0;
 301   4                                      score_2 = score;
 302   4                                      score = score_1;
 303   4                              }
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 6   

 304   3                      }
 305   2              }
 306   1      
 307   1              else{
 308   2                      if(ball_1 == 1){
 309   3                              game_over();}
 310   2                      else{
 311   3                              ball_1 = ball_1 -1;
 312   3                              }
 313   2              }
 314   1              wait_screen();
 315   1      }
 316          
 317          void draw_bricks(){
 318   1              int i;
 319   1              int j;
 320   1              int k;
 321   1              int zero_cnt = 0;
 322   1              xdata unsigned char blocks[11][5] = {0};
 323   1              if(player == 0)
 324   1              {
 325   2                      for(i= 0; i < 11; i ++)
 326   2                      {
 327   3                              for(j = 0; j < 5; j ++)
 328   3                              {
 329   4                                      blocks[i][j] = blocks_1[i][j];
 330   4                              }
 331   3                      }               
 332   2              }
 333   1              else
 334   1              {
 335   2                      for(i= 0; i < 11; i ++)
 336   2                      {
 337   3                              for(j = 0; j < 5; j ++)
 338   3                              {
 339   4                                      blocks[i][j] = blocks_2[i][j];
 340   4                              }
 341   3                      }       
 342   2              }
 343   1      
 344   1              for(i= 0; i < 11; i ++)
 345   1              {
 346   2                      for(j = 0; j < 5; j ++)
 347   2                      {
 348   3                              if(blocks[i][j] == 1)
 349   3                              {
 350   4                                      if(j%2 == 1)
 351   4                                      {
 352   5                                              for(k = 0; k < 6; k++)
 353   5                                              {
 354   6                                                      screen[((j-1)/2)*128 + i*7 +k +131] |= 0x70;
 355   6                                              }
 356   5                                      }
 357   4                                      else
 358   4                                      {
 359   5                                              for(k = 0; k < 6; k++)
 360   5                                              {
 361   6                                                      screen[(j/2)*128 + i*7 + k +131] |= 0x07;
 362   6                                              }
 363   5                                      }
 364   4                              }
 365   3                              else
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 7   

 366   3                              {
 367   4                                      zero_cnt ++;
 368   4                                      if(j%2 == 1)
 369   4                                      {
 370   5                                              for(k = 0; k < 6; k++)
 371   5                                              {
 372   6                                                      screen[(j-1)/2*128 + i*7 + k + 131] &= 0x07;
 373   6                                                      
 374   6                                              }
 375   5                                      }
 376   4                                      else
 377   4                                      {
 378   5                                              for(k = 0; k < 6; k++)
 379   5                                              {
 380   6                                                      screen[j/2*128 + i*7 + k + 131] &= 0x70;
 381   6                                              }
 382   5                                      }
 383   4                              }
 384   3                      }
 385   2              }
 386   1              if(zero_cnt == 55 && ypos > 40){
 387   2                      if(player == 0)
 388   2                      {
 389   3                              for(i= 0; i < 11; i ++)
 390   3                              {
 391   4                                      for(j = 0; j < 5; j ++)
 392   4                                      {
 393   5                                      blocks_1[i][j] = 1;
 394   5                                      }
 395   4                              }               
 396   3                      }
 397   2                      else
 398   2                      {
 399   3                              for(i= 0; i < 11; i ++)
 400   3                              {
 401   4                                      for(j = 0; j < 5; j ++)
 402   4                                      {
 403   5                                      blocks_2[i][j] = 1;
 404   5                                      }
 405   4                              }       
 406   3                      }
 407   2              } 
 408   1      }
 409          
 410          void draw_paddle(char x, char padd_w)
 411          {
 412   1              int i;
 413   1              pad_w = (int)pad_w;
 414   1              for(i = 0; i < padd_w; i ++)
 415   1              {
 416   2                      screen[898+x+i] |= 0xc0;
 417   2              }
 418   1      }
 419          
 420          unsigned char draw_ball(int x, int y)
 421          {       unsigned char row, col, shift, j, hit;
 422   1              int i;
 423   1              
 424   1              col = x-2;
 425   1              row = y - 2;
 426   1              shift = row%8;
 427   1              row = row/8;
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 8   

 428   1              //row >> 3;
 429   1              hit = 0;
 430   1              for(j = 0, i = row*128+col; j < 5; i++, j++)
 431   1              {
 432   2                      int mask = (int)ball[j] << shift;
 433   2                      hit |= screen[i]&(unsigned char)mask;
 434   2                      screen[i] |= mask;
 435   2      
 436   2                      if(mask & 0xFF00)
 437   2                      {
 438   3                              hit |= screen[i+128]&(unsigned char)(mask >> 8);
 439   3                              screen[i + 128] |= (unsigned char)(mask >> 8);
 440   3                      }
 441   2              }
 442   1              if((x<5 || x > 78) && y < 3)
 443   1              {
 444   2                      yangle = -1*yangle;
 445   2                      xangle = -1*xangle;
 446   2                      return -2;
 447   2              }
 448   1              else if(x<5 || x > 78)
 449   1              {
 450   2                      xangle = -1*xangle;
 451   2                      return -2;
 452   2              }
 453   1      
 454   1              else if (y < 3)
 455   1              {
 456   2                      yangle = -1*yangle;
 457   2                      return -2;
 458   2              }
 459   1              else if(y > 61)
 460   1              {
 461   2                      turn_end();
 462   2                      return -2;
 463   2              }
 464   1              if( y == 60 && hit > 0){
 465   2      
 466   2                      char col = xpos - pot_val -2;
 467   2                      int div = pad_w/4;
 468   2                      if( col < div || col > 3*div)
 469   2                      {
 470   3                              xangle = 2;
 471   3                              yangle = -1;
 472   3                      }
 473   2                      else
 474   2                      {
 475   3                              xangle = 1;
 476   3                              yangle = -2;
 477   3                      }
 478   2                      if(col < div *2)
 479   2                      {
 480   3                              xangle = -1*xangle;
 481   3                      }
 482   2                      //score += 1;
 483   2                      return -1;
 484   2              }
 485   1              else if( hit > 0)
 486   1              {
 487   2                      
 488   2                      int x_b, y_b;
 489   2                      score += 1;
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 9   

 490   2                      if(yangle < 0)
 491   2                      {
 492   3                              y_b = (ypos -10)/4;
 493   3                      }
 494   2                      else{
 495   3                              y_b = (ypos -6)/4;
 496   3                      }
 497   2                      if(xangle < 0)
 498   2                      {
 499   3                              x_b = (xpos -5)/7;
 500   3                      }
 501   2                      else
 502   2                      {
 503   3                              x_b = (xpos -1)/7;
 504   3                      }
 505   2                              
 506   2                      if(player == 0)
 507   2                      {
 508   3                              if(blocks_1[x_b][y_b] == 0)
 509   3                                      {
 510   4                                              if(xangle < 0)
 511   4                                                      {
 512   5                                                              y_b = (ypos -8)/4;
 513   5                                                              blocks_1[x_b-1][y_b] = 0;
 514   5                                                      }
 515   4                                              else
 516   4                                                      {
 517   5                                                              y_b = (ypos -8)/4;
 518   5                                                              blocks_1[x_b+1][y_b] = 0;
 519   5                                                      }
 520   4                                              xangle = -1*xangle;
 521   4                                      }
 522   3                              else
 523   3                              {
 524   4                                      blocks_1[x_b][y_b] = 0;
 525   4                                      yangle = -1*yangle;
 526   4                              }
 527   3                      }
 528   2                      else
 529   2                      {
 530   3                              if(blocks_2[x_b][y_b] == 0)
 531   3                              {
 532   4                                      if(xangle < 0)
 533   4                                      {
 534   5                                              blocks_2[x_b-1][y_b] = 0;
 535   5                                      }
 536   4                                      else
 537   4                                      {
 538   5                                              blocks_2[x_b+1][y_b] = 0;
 539   5                                      }
 540   4                                              xangle = -1*xangle;
 541   4                              }
 542   3                              else
 543   3                              {
 544   4                                      blocks_2[x_b][y_b] = 0;
 545   4                                      yangle = -1*yangle;
 546   4                              }       
 547   3                      }
 548   2                      if(y_b <= 3)
 549   2                      {
 550   3                              t_cnt -= (t_cnt*(1/8));
 551   3                      }
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 10  

 552   2              }
 553   1              return hit;
 554   1      }
 555          
 556          
 557          void mov_ball() {
 558   1              xpos += xangle;
 559   1              ypos += yangle;
 560   1              bonk = draw_ball(xpos, ypos);
 561   1              display();
 562   1      }
 563          
 564          void timer2(void) interrupt 5
 565          {
 566   1              
 567   1              TF2 = 0;
 568   1              int_cnt ++;
 569   1                      
 570   1      }
 571          
 572          
 573          
 574          
 575          
 576          void main()
 577          {
 578   1              WDTCN = 0xde; //disable watchdog
 579   1              WDTCN = 0xad;
 580   1              XBR2 = 0x40;  //port output
 581   1              //XBR0 = 4;       //enable uart 0
 582   1              OSCXCN = 0x67; //crystal enabled
 583   1              TMOD = 0x20;  //wait 1ms: T1 mode 2
 584   1              TH1 = 167;        // 1ms/(1/(2Mhz/12)) = 166.666
 585   1              TR1 = 1;
 586   1              while( TF1 == 0) {}     //1 ms wait for flag
 587   1              while( !(OSCXCN & 0x80)) {} //stabilize crystal
 588   1              OSCICN = 8;   // switch to 22.1184Mhz
 589   1              //SCON0 = 0x50; //8-bit, var baud, recieve enable
 590   1              //TH1 = -6;             //9600 baud
 591   1              
 592   1              IE = 0xA0;
 593   1              EIE2 = 0x06; //Timer 4 and ADC
 594   1              
 595   1              T4CON = 0x00; //timer 4, auto reload
 596   1              RCAP4H = -1;    //timer 4
 597   1              RCAP4L = -144;  //timer 4
 598   1              //REF0CN = 3;           //set up refrence voltage
 599   1              DAC0CN = 0x9C;  //DAC0CN
 600   1      
 601   1              T2CON = 0x00;
 602   1              RCAP2H = -2211 >> 8;
 603   1              RCAP2L = -2211;
 604   1      
 605   1              ADC0CN = 0x8c;
 606   1              REF0CN = 0x07;
 607   1              ADC0CF = 0x40;
 608   1              AMX0SL = 0x0;
 609   1              CKCON = 0x40;
 610   1              //EXF2 = 1;
 611   1              TR2 = 1;
 612   1              T4CON = T4CON^0x04;
 613   1              
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/18/2024 19:18:37 PAGE 11  

 614   1              init_lcd();
 615   1              //t_cnt = 50; //change depending on switches
 616   1              xpos = 40;//middle of screen
 617   1              ypos = 40;//one pixel below the bricks
 618   1      
 619   1              xangle = 1;
 620   1              yangle = 1;
 621   1              pad_w = 8;
 622   1              ball_1 = 3;
 623   1              ball_2 = 3;
 624   1              draw_ball(xpos, ypos);
 625   1              //draw_bricks();
 626   1              display();
 627   1              wait_screen();
 628   1              
 629   1              
 630   1              
 631   1              
 632   1              while(1)
 633   1              {
 634   2                      if(int_cnt==t_cnt) {
 635   3                      blank_screen();
 636   3                      draw_paddle(pot_val, pad_w);
 637   3                      draw_bricks();
 638   3                      if(bonk > 0){
 639   4                              RCAP4L = -2097;                         // set up for 659Hz
 640   4                              duration = 400;                         // one second
 641   4                              T4CON = T4CON^0x04;
 642   4                      }
 643   3                      else if(bonk ==-1)
 644   3                      {
 645   4                              RCAP4L = -2642;                         // set up for 523Hz
 646   4                              duration = 400;
 647   4                              T4CON = T4CON^0x04;
 648   4                      }
 649   3                      else if(bonk == -2)
 650   3                      {
 651   4                              RCAP4L = -2354;                         // set up for 587Hz
 652   4                              duration = 400;
 653   4                              T4CON = T4CON^0x04;
 654   4                      }
 655   3                      mov_ball();
 656   3                      int_cnt = 0;
 657   3              }
 658   2              }
 659   1      
 660   1      
 661   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3736    ----
   CONSTANT SIZE    =     76    ----
   XDATA SIZE       =    110      55
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     43      45
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
