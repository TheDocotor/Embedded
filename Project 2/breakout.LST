C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/15/2024 09:55:19 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE BREAKOUT
OBJECT MODULE PLACED IN breakout.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.exe breakout.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          #include <c8051f020.h>
   2          #include <lcd.h>
   3          #include<stdio.h>
   4          #include<stdlib.h>
   5           
   6          long score_2, score, score_1, high_score = 0;
   7          sbit player_sw = P1^7;
   8          char switches = 0; 
   9          bit player, num_player = 0;
  10          int int_cnt, t_cnt, pad_w, pot_val, count = 0;
  11          char ball_1, ball_2 = 3;
  12          char xpos, ypos, xangle, yangle = 0;
  13          code unsigned char ball[] = {0x0E, 0x1F, 0x1F, 0x1F, 0x0E};
  14          xdata unsigned char blocks_1[11][5] = {1}; 
  15          xdata unsigned char blocks_2[11][5] = {1};
  16          unsigned long sum = 0;
  17          sbit button = P2^6;
  18          
  19          void disp_char(unsigned char row, unsigned char col, char single_char);
  20          void disp_score(int x, int y, unsigned long score);
  21          void display();
  22          void mov_ball();
  23          unsigned char draw_ball(int x, int y);
  24          void wait_screen();
  25          void game_over();
  26          void turn_end();
  27          void draw_paddle(char x, char padd_w);
  28          
  29          //void adc_init(){
  30          //      REF0CN = 0x7;
  31          //      ADC0CF = 0x40;
  32          //      ADC0CN = 0x8C;
  33          //      AMX0SL = 0;
  34          //}
  35          
  36          void pot() interrupt 15{
  37   1              
  38   1              unsigned long samp = 0;
  39   1              unsigned int D;
  40   1              AD0INT = 0;
  41   1      
  42   1              D = (ADC0L|(ADC0H << 8));
  43   1      
  44   1              samp = (89L - pad_w)*D/4096;
  45   1              sum += samp;
  46   1              count++;
  47   1              
  48   1              if(count % 7 == 0)
  49   1              {
  50   2                      pot_val = sum >> 3;
  51   2                      sum = 0;
  52   2              }
  53   1      
  54   1      }
  55          
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/15/2024 09:55:19 PAGE 2   

  56          void disp_char(unsigned char row, unsigned char col, char single_char)
  57          {
  58   1              int i, j;
  59   1              unsigned char k;
  60   1              i = 128*row+col;
  61   1              j = (single_char - 0x20)*5;
  62   1              for(k = 0; k < 5; k ++) {
  63   2                      screen[i+k] = font5x8[j + k];
  64   2                      }
  65   1      }
  66          
  67          void disp_score(int x, int y, unsigned long score){
  68   1              int thou = 0;
  69   1              int hund = 0;
  70   1              int tens = 0;
  71   1              int ones = 0;
  72   1              thou = score/1000;
  73   1              score = score%1000;
  74   1              hund = score/100;
  75   1              score = score%100;
  76   1              tens =score/10;
  77   1              ones = score%10;
  78   1              disp_char(x, y, thou + '0');
  79   1              disp_char(x, y+6, hund + '0');
  80   1              disp_char(x, y+12, tens + '0');
  81   1              disp_char(x, y+18, ones + '0');
  82   1      }
  83          
  84          void display()
  85          {
  86   1              int i;
  87   1      
  88   1              if(score > high_score)
  89   1              {
  90   2                      high_score = score;
  91   2              }
  92   1      
  93   1              
  94   1              for(i = 0; i < 82; i++)
  95   1              {
  96   2                      screen[i] |= 3;
  97   2              }
  98   1              for(i = 0; i < 8; i++)
  99   1              {
 100   2                      screen[i*128] |= 255;
 101   2                      screen[i*128 + 1] |= 255;
 102   2                      screen[i*128 + 81] |= 255;
 103   2                      screen[i*128 + 80] |= 255;
 104   2              }
 105   1              disp_char(0, 89, 'H');
 106   1              disp_char(0, 95, 'I');
 107   1              disp_char(0, 101, 'G');
 108   1              disp_char(0, 107, 'H');
 109   1              disp_char(0, 113, ':');
 110   1      
 111   1              disp_score(1, 93, high_score);
 112   1      
 113   1              disp_char(2, 87, 'S');
 114   1              disp_char(2, 93, 'C');
 115   1              disp_char(2, 99, 'O');
 116   1              disp_char(2, 105, 'R');
 117   1              disp_char(2, 111, 'E');
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/15/2024 09:55:19 PAGE 3   

 118   1              disp_char(2, 117, ':');
 119   1              
 120   1              //update for two players
 121   1              disp_score(3, 93, score);
 122   1      
 123   1              disp_char(4, 99, 'P');
 124   1              disp_char(4, 105, '1');
 125   1              if(ball_1 == 3){
 126   2                      disp_char(5, 87, '*');
 127   2                      disp_char(5, 102, '*');
 128   2                      disp_char(5, 117, '*');
 129   2                      }
 130   1              else if (ball_1 == 2){
 131   2                      disp_char(5, 87, '*');
 132   2                      disp_char(5, 102, '*');
 133   2                      }
 134   1              else if(ball_1 == 1) {
 135   2                      disp_char(5, 87, '*');
 136   2                      }
 137   1              if(num_player == 1)
 138   1              {
 139   2                      disp_char(6, 99, 'P');
 140   2                      disp_char(6, 105, '2');
 141   2              }
 142   1              if(ball_2 == 3){
 143   2                      disp_char(7, 87, '*');
 144   2                      disp_char(7, 102, '*');
 145   2                      disp_char(7, 117, '*');
 146   2                      }
 147   1              else if (ball_2 == 2){
 148   2                      disp_char(7, 87, '*');
 149   2                      disp_char(7, 102, '*');
 150   2                      }
 151   1              else if(ball_2 == 1) {
 152   2                      disp_char(7, 87, '*');
 153   2                      }
 154   1      
 155   1              //potentially update player scores here
 156   1              if(player == 0)
 157   1              {
 158   2                      disp_char(4, 93, '-');
 159   2                      disp_char(4, 111, '-');
 160   2              }
 161   1              else
 162   1              {
 163   2                      disp_char(6, 93, '-');
 164   2                      disp_char(6, 111, '-');
 165   2              }
 166   1      
 167   1              refresh_screen();
 168   1      }
 169          
 170          void wait_screen(){
 171   1              TR2 = 0;
 172   1              xpos = 36;//middle of screen
 173   1              ypos = 24;//one pixel below the bricks
 174   1              xangle = 1;
 175   1              yangle = 1;
 176   1              //blank_screen();
 177   1              
 178   1              
 179   1              disp_char(2, 30, 'P');
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/15/2024 09:55:19 PAGE 4   

 180   1              disp_char(2, 36, 'R');
 181   1              disp_char(2, 42, 'E');
 182   1              disp_char(2, 48, 'S');
 183   1              disp_char(2, 54, 'S');
 184   1              disp_char(3, 30, 'S');
 185   1              disp_char(3, 36, 'T');
 186   1              disp_char(3, 42, 'A');
 187   1              disp_char(3, 48, 'R');
 188   1              disp_char(3, 54, 'T');
 189   1              refresh_screen();
 190   1              //display();
 191   1              if(ball_1 == 3 && ball_2 == 3){ 
 192   2                      while (button == 1){
 193   3                      pad_w = P1&3;
 194   3                      num_player = player_sw;
 195   3                      
 196   3                              }
 197   2                      if(pad_w == 3){
 198   3                              pad_w = 24;
 199   3                      }
 200   2                      else{
 201   3                              pad_w = pad_w*4 +8;
 202   3                      }
 203   2      
 204   2                      if(num_player == 0){
 205   3                      ball_2 = 0;
 206   3                      }
 207   2              }
 208   1              else{
 209   2                      while (button == 1){};
 210   2              }
 211   1              TR2 = 1;        
 212   1      }
 213          
 214          
 215          void game_over()
 216          {
 217   1              TR2 = 0;
 218   1      
 219   1              //blank_screen();
 220   1              disp_char(2, 30, 'G');
 221   1              disp_char(2, 36, 'A');
 222   1              disp_char(2, 42, 'M');
 223   1              disp_char(2, 48, 'E');
 224   1              disp_char(3, 30, 'O');
 225   1              disp_char(3, 36, 'V');
 226   1              disp_char(3, 42, 'E');
 227   1              disp_char(3, 48, 'R');
 228   1      
 229   1              disp_char(0, 89, 'H');
 230   1              disp_char(0, 95, 'I');
 231   1              disp_char(0, 101, 'G');
 232   1              disp_char(0, 107, 'H');
 233   1              disp_char(0, 113, ':');
 234   1      
 235   1              //disp_score(1, 93, high_score);
 236   1      
 237   1              disp_char(2, 87, 'S');
 238   1              disp_char(2, 93, 'C');
 239   1              disp_char(2, 99, 'O');
 240   1              disp_char(2, 105, 'R');
 241   1              disp_char(2, 111, 'E');
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/15/2024 09:55:19 PAGE 5   

 242   1              disp_char(2, 117, ':');
 243   1              
 244   1              //update for two players
 245   1              //disp_score(3, 93, score);
 246   1              refresh_screen();
 247   1              while(1){}
 248   1              //display();
 249   1      }
 250          
 251          void turn_end()
 252          {
 253   1              if(num_player == 1){
 254   2                      
 255   2                      if(player == 0){
 256   3                              ball_1 = ball_1 -1;
 257   3                              player = 1;
 258   3                              score_1 = score;
 259   3                              score = score_2;
 260   3                      }
 261   2                      else{
 262   3                              if(ball_2 == 1){
 263   4                                      game_over();}
 264   3                              else{
 265   4                                      ball_2 = ball_2 -1;
 266   4                                      player = 0;
 267   4                                      score_2 = score;
 268   4                                      score = score_1;
 269   4                              }
 270   3                      }
 271   2              }
 272   1      
 273   1              else{
 274   2                      if(ball_1 == 1){
 275   3                              game_over();}
 276   2                      else{
 277   3                              ball_1 = ball_1 -1;
 278   3                              }
 279   2              }
 280   1              wait_screen();
 281   1      }
 282          
 283          void draw_bricks(){
 284   1              int i;
 285   1              int j;
 286   1              int k;
 287   1              xdata unsigned char blocks[11][5] = {0};
 288   1              if(player == 0)
 289   1              {
 290   2                      for(i= 0; i < 11; i ++)
 291   2                      {
 292   3                              for(j = 0; j < 5; j ++)
 293   3                              {
 294   4                                      blocks[i][j] = blocks_1[i][j];
 295   4                              }
 296   3                      }               
 297   2              }
 298   1              else
 299   1              {
 300   2                      for(i= 0; i < 11; i ++)
 301   2                      {
 302   3                              for(j = 0; j < 5; j ++)
 303   3                              {
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/15/2024 09:55:19 PAGE 6   

 304   4                                      blocks[i][j] = blocks_2[i][j];
 305   4                              }
 306   3                      }       
 307   2              }
 308   1      
 309   1              for(i= 0; i < 11; i ++)
 310   1              {
 311   2                      for(j = 0; j < 5; j ++)
 312   2                      {
 313   3                              if(blocks[i][j] == 1)
 314   3                              {
 315   4                                      if(j%2 == 1)
 316   4                                      {
 317   5                                              for(k = 0; k < 6; k++)
 318   5                                              {
 319   6                                                      screen[(j-1)*132 + i*8 +k +132] |= 0x70;
 320   6                                              }
 321   5                                      }
 322   4                                      else
 323   4                                      {
 324   5                                              for(k = 0; k < 6; k++)
 325   5                                              {
 326   6                                                      screen[j*132 + i*8 + k +132] |= 0x07;
 327   6                                              }
 328   5                                      }
 329   4                              }
 330   3                              else
 331   3                              {
 332   4                                      if(j%2 == 1)
 333   4                                      {
 334   5                                              for(k = 0; k < 6; k++)
 335   5                                              {
 336   6                                                      screen[(j-1)*132 + i*8 +k] &= 0x07;
 337   6                                              }
 338   5                                      }
 339   4                                      else
 340   4                                      {
 341   5                                              for(k = 0; k < 6; k++)
 342   5                                              {
 343   6                                                      screen[j*132 + i*8 + k] &= 0x70;
 344   6                                              }
 345   5                                      }
 346   4                              }
 347   3                      }
 348   2              }
 349   1      }
 350          
 351          void draw_paddle(char x, char padd_w)
 352          {
 353   1              int i;
 354   1              pad_w = (int)pad_w;
 355   1              for(i = 0; i < padd_w; i ++)
 356   1              {
 357   2                      screen[898+x+i] |= 0xc0;
 358   2              }
 359   1      }
 360          
 361          unsigned char draw_ball(int x, int y)
 362          {       unsigned char row, col, shift, j, hit;
 363   1              int i;
 364   1              if(x<5 || x > 78)
 365   1              {
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/15/2024 09:55:19 PAGE 7   

 366   2                      xangle = -1*xangle;
 367   2                      return 0;
 368   2              }
 369   1      
 370   1              else if (y < 3)
 371   1              {
 372   2                      yangle = -1*yangle;
 373   2                      return 0;
 374   2              }
 375   1              else if(y > 61)
 376   1              {
 377   2                      turn_end();
 378   2                      return 0;
 379   2              }
 380   1              col = x-2;
 381   1              row = y - 2;
 382   1              shift = row%8;
 383   1              row = row/8;
 384   1              //row >> 3;
 385   1              hit = 0;
 386   1              for(j = 0, i = row*128+col; j < 5; i++, j++)
 387   1              {
 388   2                      int mask = (int)ball[j] << shift;
 389   2                      hit |= screen[i]&(unsigned char)mask;
 390   2                      screen[i] |= mask;
 391   2      
 392   2                      if(mask & 0xFF00)
 393   2                      {
 394   3                              hit |= screen[i+128]&(unsigned char)(mask >> 8);
 395   3                              screen[i + 128] |= (unsigned char)(mask >> 8);
 396   3                      }
 397   2              }
 398   1              if( y == 60 && hit > 0){
 399   2                      char col = xpos - pot_val -2;
 400   2                      int div = pad_w/4;
 401   2                      if( col < div || col > 3*div)
 402   2                      {
 403   3                              xangle = 2;
 404   3                              yangle = -1;
 405   3                      }
 406   2                      else
 407   2                      {
 408   3                              xangle = 1;
 409   3                              yangle = -2;
 410   3                      }
 411   2                      if(col < div *2)
 412   2                      {
 413   3                              xangle = -1*xangle;
 414   3                      }
 415   2                      score += 1;
 416   2                      return 0;
 417   2              }
 418   1              return hit;
 419   1      }
 420          
 421          
 422          void mov_ball() {
 423   1              xpos += xangle;
 424   1              ypos += yangle;
 425   1              draw_ball(xpos, ypos);
 426   1              display();
 427   1      }
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/15/2024 09:55:19 PAGE 8   

 428          
 429          void timer2(void) interrupt 5
 430          {
 431   1              
 432   1              TF2 = 0;
 433   1              int_cnt ++;
 434   1              if(int_cnt==t_cnt) {
 435   2                      blank_screen();
 436   2                      draw_paddle(pot_val, pad_w);
 437   2                      draw_bricks();
 438   2                      mov_ball();
 439   2                      int_cnt = 0;
 440   2              }
 441   1                      
 442   1      }
 443          
 444          
 445          
 446          
 447          
 448          void main()
 449          {
 450   1              WDTCN = 0xde; //disable watchdog
 451   1              WDTCN = 0xad;
 452   1              XBR2 = 0x40;  //port output
 453   1              //XBR0 = 4;       //enable uart 0
 454   1              OSCXCN = 0x67; //crystal enabled
 455   1              TMOD = 0x20;  //wait 1ms: T1 mode 2
 456   1              TH1 = 167;        // 1ms/(1/(2Mhz/12)) = 166.666
 457   1              TR1 = 1;
 458   1              while( TF1 == 0) {}     //1 ms wait for flag
 459   1              while( !(OSCXCN & 0x80)) {} //stabilize crystal
 460   1              OSCICN = 8;   // switch to 22.1184Mhz
 461   1              //SCON0 = 0x50; //8-bit, var baud, recieve enable
 462   1              //TH1 = -6;             //9600 baud
 463   1              
 464   1              IE = 0xA0;
 465   1              EIE2 = 0x02;
 466   1      
 467   1              T2CON = 0x00;
 468   1              RCAP2H = -2211 >> 8;
 469   1              RCAP2L = -2211;
 470   1      
 471   1              ADC0CN = 0x8c;
 472   1              REF0CN = 0x07;
 473   1              ADC0CF = 0x40;
 474   1              AMX0SL = 0x0;
 475   1      
 476   1              TR2 = 1;
 477   1              
 478   1              init_lcd();
 479   1              t_cnt = 50; //change depending on switches
 480   1              xpos = 36;//middle of screen
 481   1              ypos = 24;//one pixel below the bricks
 482   1      
 483   1              xangle = 1;
 484   1              yangle = 1;
 485   1              pad_w = 8;
 486   1              ball_1 = 3;
 487   1              ball_2 = 3;
 488   1              draw_ball(xpos, ypos);
 489   1              display();
C51 COMPILER V9.59.0.0   BREAKOUT                                                          04/15/2024 09:55:19 PAGE 9   

 490   1              wait_screen();
 491   1              
 492   1              
 493   1              
 494   1              
 495   1              while(1)
 496   1              {
 497   2              }
 498   1      
 499   1      
 500   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2959    ----
   CONSTANT SIZE    =     60    ----
   XDATA SIZE       =    110      55
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     37      42
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
